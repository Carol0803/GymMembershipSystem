/*
Project Title: Gym Membership System
Team members : Wong Kak Lok (B032010436)
			   Muhammad Haziq bin Mohd Hapiz (B032010199)
Compiler: Visual Studio 2019

Implementation Class File (Member.cpp)

- Algorithm Analysis -
Some function is doing O(n^2) iteration like simpleSort and displayMember function. But most of it are in O(n) iteration.
Since this is a small project and consist of simple implementation that involves small data sets, it is efficient to use O(n^2) without having any difficulities.
Thus, the overall algorithm analysis for this project is O(n^2).

*/

#include <iostream>
#include <ctime>
#include <iomanip>
#include "Member.h"
using namespace std;

// Member() - This function is a constructor that initializes the variables.
// The pointer front and rear also point to NULLI to build an empty queue.
Member::Member() {
	front = NULL;
	rear = NULL;
	count = 0;

	size = 0;
	memID = 0;
}

// ~Member() - This is a default destructor.
Member::~Member() {}

// bool Empty() - This function checks whether the queue is empty.
// It returns true when the count equals 0.
bool Member::Empty() {
	return(count == 0);
}
/*
void enqueueMember() - This function inserts new-registered member's data into a queue linked list.
A new node, N is created and inputs are inserted into the data part of N.
Data such as name, IC no., gender, subscription type, height, weight are inputs by user.
Other data such as age, membership expiry date and BMI value are calculated from the input's data.
The member ID is generated by the system according to the sequence of membership registration.
The pointer next of N will point to NULL.
If the queue is not empty, the pointer rear->next will point to N.
Else, the pointer front will point to N.
The pointer rear will point to N.
The value of count and size is added. */
void Member::enqueueMember() {
	cout << "======================================================\n";
	cout << "\t\tNEW MEMBER REGISTRATION" << endl;
	cout << "======================================================\n";

	Node* N = new Node;

	cin.ignore();
	cout << "Enter name: ";
	getline(cin, N->data.name);

	cout << "Enter IC Number: ";
	cin >> N->data.ic;

	int year;
	year = ((N->data.ic[0] - '0') * 10) + (N->data.ic[1] - '0');
	if (year <= 21)
		year += 2000;
	else
		year += 1900;
	N->data.age = 2021 - year;

	cout << "Enter gender (M-Male / F-Female): ";
	cin >> N->data.gender;

	cout << "Choose subscription type (M-Monthly / A-Annually): ";
	cin >> N->data.type;
	char subsType = N->data.type;
	N->data.expDate = getExpiryDate(subsType);

	cout << "Enter height(in metre): ";
	cin >> N->data.height;

	cout << "Enter weight(in kg): ";
	cin >> N->data.weight;

	N->data.bmi = ("%.2f", (N->data.weight / pow(N->data.height, 2)));

	if (memID == 0)
		memID = 1000;
	N->data.memberID = ++memID;

	N->next = NULL;

	if (!Empty())
		rear->next = N;
	else
		front = N;

	count++;
	rear = N;
	size++;
}
/*
void dequeueMember() - This function removes new-registered member's data from the queue linked list.
If the queue is empty, the error message "Underflow!" will be displayed.
Else, a temp pointer is created and pointed to the front node. If there is only one node in the queue,
pointer front and rear become NULL, if not the pointer front will point to the next node.
The value of count decreased by one and temp is deleted. */
void Member::dequeueMember() {
	if (Empty())
		cout << "Underflow!";
	else {
		Node* temp = front;
		if (count == 1)
			rear = front = NULL;
		else
			front = front->next;
		count--;
		delete temp;
	}
}
/*
string getCurrentDate() - This function gets and returns the current date when the program is running.
The <ctime> header file needs to be included in order to access related functions and structures.
The time_t currenttime = time(0) function returns the current calendar time of the system while
the tm* now = localtime(&currenttime) structure returns pointer to the tm now structure representing local time.
The current date obtained from the structure will be stored in integer variables Cyear, Cmonth and Cday.
Then the integer variables will convert and combine to form a string date in YYYYMMDD format.
The string date is returned. */
string Member::getCurrentDate() {
#pragma warning(disable : 4996)
	time_t currenttime = time(0);
	tm* now = localtime(&currenttime);

	int Cyear, Cmonth, Cday;
	string day, month, year;
	Cyear = 1900 + now->tm_year;
	Cmonth = 1 + now->tm_mon;
	Cday = now->tm_mday;

	day = (Cday < 10) ? "0" + to_string(Cday) : to_string(Cday);
	month = (Cmonth < 10) ? "0" + to_string(Cmonth) : to_string(Cmonth);
	year = to_string(Cyear);

	return year + month + day;
}
/*
string getExpiryDate(char subsType) - This function gets and returns the expiry date of membership.
This function will undergoes same process as getCurrentDate() function until the current date obtained is stored in
integer variables Cyear, Cmonth and Cday.
Then, the process will continue based on the subscription type chosen by the user.
If the user chooses a monthly subscription, the program will add 30 days on current date to generate the expiry date of subscription.
If the user chooses an annual subscription, the program will add 365 days on the current date to generate the expiry date of subscription.
The expiry date will be returned in string form of DD/MM/YYYY format. */
string Member::getExpiryDate(char subsType) {
#pragma warning(disable : 4996)
	time_t currenttime = time(0);
	tm* now = localtime(&currenttime);

	int Cyear, Cmonth, Cday;
	string day, month, year;
	Cyear = 1900 + now->tm_year;
	Cmonth = 1 + now->tm_mon;
	Cday = now->tm_mday;

	int daysOfMonth[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	int addDays = 0;

	if (subsType == 'M' || subsType == 'm')
		addDays = 30;
	else if (subsType == 'A' || subsType == 'a')
		addDays = 365;

	for (int i = 0; i < addDays; i++) {
		if (Cday < daysOfMonth[Cmonth - 1])
			Cday++;
		else if (Cday == daysOfMonth[Cmonth - 1] && Cmonth < 12) {
			Cday = 1;
			Cmonth++;
		}
		else if (Cday == daysOfMonth[Cmonth - 1] && Cmonth == 12) {
			Cday = 1;
			Cmonth = 1;
			Cyear++;
		}
	}

	day = (Cday < 10) ? "0" + to_string(Cday) : to_string(Cday);
	month = (Cmonth < 10) ? "0" + to_string(Cmonth) : to_string(Cmonth);
	year = to_string(Cyear);

	return day + "/" + month + "/" + year;
}
/*
void fetchData() - This function is used to fetch data from main array into a sub-array.
The purpose of this function is to avoid any changes in main array list.
So it will not affecting the main array list when the sorting function is being applied.
A new sub array sortedList[] and main array memberList[] will be in a for-loop and going to stop depending on the size of the main array list.
All data from each struct of memberList will be assigned into its own position in a new struct sortedList.
For example: sortedList[1] is getting data from memberList[1] */
void Member::fetchData() {
	for (int i = 0; i < size; i++) {
		sortedList[i].name = memberList[i].name;
		sortedList[i].ic = memberList[i].ic;
		sortedList[i].memberID = memberList[i].memberID;
		sortedList[i].gender = memberList[i].gender;
		sortedList[i].age = memberList[i].age;
		sortedList[i].type = memberList[i].type;
		sortedList[i].expDate = memberList[i].expDate;
		sortedList[i].height = memberList[i].height;
		sortedList[i].weight = memberList[i].weight;
		sortedList[i].bmi = memberList[i].bmi;
	}
}
/*
void simpleSort() - This function sort array list using simple sort technique.
The sub array list, sortedList[], is created by fetching data from the array list.
After that, the sub array list is sorted by the name of the member using a simple sort technique.
The details process of how simple sort works is as below:
The list is traverse to find the smallest name, when the smallest name is found,
the subscript of the respective sortedList[] is set to int min(sortedList[min]). The sortedList[min]'s data
will exchange with the sub array's data in the first location. Then, the process will continue with traversing to
find the second smallest data and exchange it with data at the second location. This process is repeated until all data are
stored in ascending order of member's name.
If there is two members with closely alike name, the program will compared each character of their name until
it can identify which name is smaller. */
void Member::simpleSort() {
	fetchData();

	for (int i = 0; i < size - 1; i++) {
		int min = i;
		for (int j = i + 1; j < size; j++) {
			int a = 0;
			while (sortedList[j].name[a] == sortedList[min].name[a]) {
				a++;
				if (sortedList[j].name[a] != sortedList[min].name[a])
					break;
			}
			if (sortedList[j].name < sortedList[min].name)
				min = j;
		}

		Details temp;
		temp = sortedList[min];
		sortedList[min] = sortedList[i];
		sortedList[i] = temp;
	}
}
/*
void displaySortedList() - This function display namelist of sorted sub array list.
The simpleSort() function is called to sort the sub array list, sortedList[].
All the data in sortedList[] of all members that registered the membership will be displayed in a table.
The data include name, IC no., age, gender, height, weight, BMI, subscription type, member ID and membership expiry date.
The data with double data type are displayed with two decimal points. */
void Member::displaySortedList() {

	simpleSort();

	string gender[maxSize], type[maxSize];
	for (int a = 0; a < size; a++) {
		if (sortedList[a].gender == 'M' || sortedList[a].gender == 'm')
			gender[a] = "Male";
		else if (sortedList[a].gender == 'F' || sortedList[a].gender == 'f')
			gender[a] = "Female";

		if (sortedList[a].type == 'M' || sortedList[a].type == 'm')
			type[a] = "Monthly";
		else if (sortedList[a].type == 'A' || sortedList[a].type == 'a')
			type[a] = "Annually";
	}
	cout << "============================================================================================================================================\n";
	cout << right << setw(75) << "MEMBER'S NAMELIST" << endl;
	cout << "============================================================================================================================================\n";

	cout << left << setw(4) << "NO." << setw(20) << "NAME" << setw(17) << "IC NO." << setw(8) << "AGE" << setw(12) << "GENDER"
		<< setw(12) << "HEIGHT(M)" << setw(12) << "WEIGHT(KG)" << setprecision(2) << setw(8) << "BMI" << setw(20) << "SUBSCRIPTION TYPE" << setw(15) << "MEMBER ID"
		<< setw(15) << "EXPIRY DATE" << endl;
	for (int i = 0; i < size; i++) {
		cout << fixed << left << setw(4) << i + 1 << setw(20) << sortedList[i].name << setw(17) << sortedList[i].ic << setw(8)
			<< sortedList[i].age << setw(12) << gender[i] << setw(12) << setprecision(2) << sortedList[i].height << setw(12)
			<< setprecision(2) << sortedList[i].weight << setw(8) << setprecision(2) << sortedList[i].bmi << setw(20) << type[i] << setw(15) << sortedList[i].memberID
			<< setw(15) << sortedList[i].expDate << endl;
	}
}
/*
void displayMember(int) - This function displays list of membership subscribers either active or expired membership.
The function parameter will receive integer value either 0 or 1 based on input by user what it want to be displayed (Active / Expired).
fetchData() and simpleSort() functions are called to get the current data into a sub-array list and sort it using simple sort algorithm.
getCurrentDate() function also being called to get the current date value in YYYYMMDD format for comparison purpose later in this function.
The function also will getting every expired date value from each membership data and they will go through a process to remove "/" symbol from its value.
So it also will be in YYYYMMDD format.
If the parameter value is 1, it will filter out the membership list with a condition current date is less than expired date. (Active membership list)
Else if the paramater value is 0, it will filter out the membership list with a condition current date is greater than expired date. (Expired membership list)
After the filter out process, the name list will be displayed. */
void Member::displayMember(int active) {
	fetchData();
	simpleSort();
	string gender[maxSize], type[maxSize];
	for (int a = 0; a < size; a++) {
		if (memberList[a].gender == 'M' || memberList[a].gender == 'm')
			gender[a] = "Male";
		else if (memberList[a].gender == 'F' || memberList[a].gender == 'f')
			gender[a] = "Female";

		if (memberList[a].type == 'M' || memberList[a].type == 'm')
			type[a] = "Monthly";
		else if (memberList[a].type == 'A' || memberList[a].type == 'a')
			type[a] = "Annually";
	}

	cout << "============================================================================================================================================\n";
	if (active == 1)
		cout << right << setw(75) << "ACTIVE MEMBERSHIP NAMELIST" << endl;
	else
		cout << right << setw(75) << "EXPIRED MEMBERSHIP NAMELIST" << endl;
	cout << "============================================================================================================================================\n";

	cout << left << setw(20) << "NAME" << setw(17) << "IC NO." << setw(8) << "AGE" << setw(12) << "GENDER"
		<< setw(12) << "HEIGHT(M)" << setw(12) << "WEIGHT(KG)" << setw(8) << setprecision(2) << "BMI" << setw(20) << "SUBSCRIPTION TYPE" << setw(15) << "MEMBER ID"
		<< setw(15) << "EXPIRY DATE" << endl;

	string cD = getCurrentDate(); // currentDate

	for (int i = 0; i < size; i++) {
		string eD = sortedList[i].expDate; // expiredDate
		string chars = "/";

		for (char c : chars)
			eD.erase(remove(eD.begin(), eD.end(), c), eD.end());

		string d = string() + eD.substr(4, 7) + eD.substr(2, 2) + eD.substr(0, 2);

		if (active == 0) {
			if (cD > d) {
				cout << fixed << left << setw(20) << sortedList[i].name << setw(17) << sortedList[i].ic << setw(8)
					<< sortedList[i].age << setw(12) << gender[i] << setw(12) << setprecision(2) << sortedList[i].height << setw(12)
					<< setprecision(2) << sortedList[i].weight << setw(8) << setprecision(2) << sortedList[i].bmi << setw(20) << type[i] << setw(15) << sortedList[i].memberID
					<< setw(15) << sortedList[i].expDate << endl;
			}
		}
		else {
			if (cD <= d) {
				cout << fixed << left << setw(20) << sortedList[i].name << setw(17) << sortedList[i].ic << setw(8)
					<< sortedList[i].age << setw(12) << gender[i] << setw(12) << setprecision(2) << sortedList[i].height << setw(12)
					<< setprecision(2) << sortedList[i].weight << setw(8) << setprecision(2) << sortedList[i].bmi << setw(20) << type[i] << setw(15) << sortedList[i].memberID
					<< setw(15) << sortedList[i].expDate << endl;
			}
		}
	}
}
/*
void loadData() - This function is to load any existing data from a stored file in the system.
The function will read data.txt file and try to open it if it exist. If it doesn't exist, it will just skip it and end the function.
It will read the very first line in data.txt which is a size of the current existing data that has been stored in this file.
After that it will go through a for-loop to get each data from every line and assign it into main array list, memberList[] and stop after no line of data left to be read. */
void Member::loadData() {

	ifstream readFile("data.txt", ios::in);

	while (readFile.is_open()) {
		readFile >> size; // get total of data has been stored
		for (int i = 0; i < size; i++) {
			readFile.get();
			getline(readFile, memberList[i].name);
			getline(readFile, memberList[i].ic);
			readFile
				>> memberList[i].memberID
				>> memberList[i].gender
				>> memberList[i].age
				>> memberList[i].type
				>> memberList[i].expDate
				>> memberList[i].height
				>> memberList[i].weight
				>> memberList[i].bmi;
			memID = memberList[i].memberID; // get latest value of memberID to generate new memberID for new registration
		}
		cout << "\nFile Loaded Successfully\n";
		readFile.close();
	}
}
/*
void addItem() - This function add the data from queue linked list into main array list.
The function starts with creating a new temporary file, temp.txt in the system.
Then, the program will write each data from main array list, memberList[] into the temporary file.
After it's done, each data from queue linked list will be assigned into the memberList[] and being dequeue right away.
The data from this queue linked list will also be written in the temp.txt file.
This process for queue linked list is being repeated until no data exist in the queue.
data.txt file will be deleted if it's exist within the system and temp.txt will be renamed to a new data.txt file. */
void Member::addItem() {
	cout << "======================================================\n";
	cout << "\t\tPROCESS REGISTRATION" << endl;
	cout << "======================================================\n";
	cout << "Processing..." << endl;

	if (size == maxSize)
	{
		cout << "Max number of members reached.";
		return;
	}

	int k = 0;
	ofstream writeFile("temp.txt", ios::out | ios::app);
	writeFile << size << endl;

	for (int i = 0; i < size - count; i++) {
		writeFile
			<< memberList[i].name << endl
			<< memberList[i].ic << endl
			<< memberList[i].memberID << endl
			<< memberList[i].gender << endl
			<< memberList[i].age << endl
			<< memberList[i].type << endl
			<< memberList[i].expDate << endl
			<< memberList[i].height << endl
			<< memberList[i].weight << endl
			<< memberList[i].bmi << endl;
		k++;
	}
	for (int i = k; i <= size; i++) {
		if (Empty())
			break;

		memberList[i].name = front->data.name;
		memberList[i].memberID = front->data.memberID;
		memberList[i].gender = front->data.gender;
		memberList[i].ic = front->data.ic;
		memberList[i].age = front->data.age;
		memberList[i].type = front->data.type;
		memberList[i].expDate = front->data.expDate;
		memberList[i].height = front->data.height;
		memberList[i].weight = front->data.weight;
		memberList[i].bmi = front->data.bmi;

		dequeueMember();
		writeFile
			<< memberList[i].name << endl
			<< memberList[i].ic << endl
			<< memberList[i].memberID << endl
			<< memberList[i].gender << endl
			<< memberList[i].age << endl
			<< memberList[i].type << endl
			<< memberList[i].expDate << endl
			<< memberList[i].height << endl
			<< memberList[i].weight << endl
			<< memberList[i].bmi << endl;
	}
	writeFile.close();
	remove("data.txt");
	rename("temp.txt", "data.txt");

	cout << "Succeed!\n";
}
/*
void renewSubs() - This function renew membership subscription.
The function will start with run the simpleSort function and display the membership list through displaySortedList.
Then, user will enter IC number of the member that want to renew their membership subscription and subscription type (Monthly or Annually).
The function will do searching through the for loop iteration and if-statement to get into the specific member of the IC number that have been entered.
The program will calculate new expiry date for the subscription based on the current date and subscription type that has been entered.
Subscription type and new expiry date will be updated in the main array, memberList[] and also sub array, sortedList[]. */
void Member::renewSubs() {
	simpleSort();
	displaySortedList();
	cout << "\n======================================================\n";
	cout << "\t\tRENEW SUBSCRIPTION" << endl;
	cout << "======================================================\n";
	string numIC;
	char type;
	cout << "Enter IC number: ";
	cin >> numIC;
	cout << "Choose subscription type (M-Monthly / A-Annually): ";
	cin >> type;

	for (int i = 0; i < size; i++) {
		if (numIC == memberList[i].ic) {
			memberList[i].type = type;
			memberList[i].expDate = getExpiryDate(type);
		}
	}
	for (int i = 0; i < size; i++) {
		if (numIC == memberList[i].ic) {
			sortedList[i].type = type;
			sortedList[i].expDate = getExpiryDate(type);
		}
	}
	cout << "Process succeed!" << endl;
}